# 锁住同步资源失败，线程要不要阻塞？

阻塞

不阻塞：**自旋锁与适应性自旋锁**

---

**阻塞**或**唤醒**一个 Java 线程需要操作系统切换 CPU 状态来完成，需要耗费 CPU 时间。如果同步代码块中的内容过于简单，**状态切换的时间可能会大于代码执行时间。**

### 自旋锁

我们可以让当前请求锁的线程通过**自旋**来「稍等一下」，如果自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以**不必阻塞**而是直接获取同步资源，从而避免切换线程的开销，这就是**自旋锁**。

**原理**：就是 CAS，`AtomicInteger` 中调用 `unsafe` 进行自增操作中的 `do-while` 循环就是一个自旋操作

**缺点**：

- 不能代替阻塞，虽然避免了线程切换的开销，但也是**会占用 CPU 的时间**。如果锁被占用的时间非常短，自旋的效果就非常好，反之，自旋则是白白浪费时间。所以自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认 10 次，可以使用 `-XX:PreBlockSpin` 来更改）没有成功获得锁，就应当挂起线程。
- ABA 问题：一个变量 V 的值得变化是 A → B → A，CAS 操作就会误认为它从来没有被改变过
    - 解决办法：`java.util.concurrent` 包为了解决这个问题，提供了一个带有标记的原子引用类 `AtomicStampedReference` ，它可以通过控制变量值的版本来保证CAS的正确性。不过目前来说这个类比较「鸡肋」，**大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。**

### 适应性自旋锁

自旋锁在 JDK 1.4.2 中引用，使用 `-XX:+UseSpining` 来开启。JDK 6 中变为了默认开启，并引入了适应性自旋锁。

**特点**：适应性意味着自旋时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。**前一次自旋等待刚刚成功获得过锁，则虚拟机就会认为这一次自旋可能再次成功，进而允许自旋等待的时间更长。反之，对于某个锁，自旋很少成功获得过，则在以后的尝试中可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。**