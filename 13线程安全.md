# 线程安全以及实现方法

多线程安全问题的**本质**是，在多个线程并发操作的时候，一个线程写操作进行到了一半，没有结束的时候，另一个线程就进行了读写操作

- A 线程写了一半，B 线程就去读了
- A 线程写了一半，B 线程基于这个一半的操作又继续写

**线程安全的实现方法**

1. **互斥同步。**互斥是指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。
    - 互斥是因，同步是果；互斥是方法，同步是目的
    - Java 中最基本的互斥同步手段就是 `synchronized` 关键字
    - [synchronized 与 Lock 的原理](https://www.notion.so/99ac7a3b-b624-485a-b7b7-30d2ec1cfdaa)
    - 互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为**阻塞同步**（BlockingSynchronization）。从处理问题的方式上说，互斥同步属于一种**悲观的并发策略**，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒。
2. **非阻塞同步**
    - 原理
        - 基于冲突检测的**乐观并发策略**，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了
        - 如果共享数据**有冲突**，那就再采取其他的补偿措施（最常见的补偿措施就是**不断地重试**，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步
    - 实现：使用**硬件指令集**来实现「操作」和「冲突检测」这两个步骤的**原子性**
        - 比较与交换 Compare-and-swap，简称 **CAS**
            - CAS 指令需要有 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用V表示）、旧的预期值（用A表示）和新值（用B表示）。CAS 指令执行时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是原子操作
            - 在JDK1.5之后，Java程序中才可以使用 CAS 操作，该操作由`sun.misc.Unsafe` 类里面的 `compareAndSwapInt()` 和 `compareAndSwapLong()` 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条**平台相关的处理器CAS指令**
            - [锁住同步资源失败，线程要不要阻塞？](https://www.notion.so/4705d9ee-d695-4286-9a5f-5374d0071335)
3. **无同步方案**

    如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的

    - 可重入代码：**不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等**。我们可以通过一个简单的原则来判断代码是否具备可重入性：如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。
    - 线程本地存储：把**共享数据的可见范围限制在同一个线程之内**，这样，无须同步也能保证线程之间不出现数据争用的问题。
        - 如「生产者消费者」模式都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的「一个请求对应一个服务器线程」（ThreadperRequest）的处理方式。
        - 如果一个变量要被多线程访问，可以使用 `volatile` 关键字声明它为「易变的」；如果一个**变量要被某个线程独享**，可以通过 `java.lang.**ThreadLocal**` 类来实现线程本地存储的功能。每一个线程的 Thread 对象中都有一个 `ThreadLocalMap` 对象，
            - K: ThreadLocal.threadLocalHashCode
            - V: 本地线程变量

            ThreadLocal 对象就是当前线程的 ThreadLocalMap 的访问入口，每一个 ThreadLocal 对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程 KV 值对中找回对应的本地线程变量。

            例如，Looper 就是线程独享的，使用的 ThreadLocal